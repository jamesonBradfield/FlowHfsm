@tool
class_name LogicSmasher extends RefCounted

## Logic Smasher
##
## Compiles a RecursiveState's child evaluation logic into a hardcoded GDScript.
## optimization: O(N) -> O(1) (State Selection)
##
## "Fixing the Cart":
## 1. Auto-wires references (no more manual assignment).
## 2. Hides internal variables from Inspector (cleaner UX).
## 3. Uses Array buffering instead of string concatenation (cleaner code).

const TEMPLATE = """extends RecursiveState

# --- SMASHED STATE ---
# Generated by LogicSmasher (Ultimate Stack Edition).
# Target Node: {target_node_name}
# Timestamp: {timestamp}
# Do not edit manually. Re-smash if hierarchy changes.

{property_declarations}

func _get_property_list() -> Array[Dictionary]:
	return {property_list_data}

func process_state(delta: float, actor: Node, blackboard: Blackboard = null) -> void:
	# 0. Blackboard Check (Optimized inline)
	if not blackboard:
		blackboard = get_blackboard()
	
	# 1. PRIORITY EVALUATION (Smashed)
	var best_child: RecursiveState = null
	
{logic_body}
	
	# 2. SWITCH & UPDATE
	if best_child != null and best_child != active_child:
		if not active_child or not active_child.is_hierarchy_locked():
			change_active_child(best_child, actor, blackboard)
			
	# 3. BEHAVIOR UPDATE (Typed Optimized)
	{behavior_logic}
		
	# 4. RECURSION
	if active_child:
		active_child.process_state(delta, actor, blackboard)
"""

## Generates the optimized script source code.
static func smash(node: RecursiveState) -> String:
	var children: Array[RecursiveState] = []
	for c in node.get_children():
		if _is_state(c): children.append(c)
	
	var prop_decls: PackedStringArray = []
	var prop_list_items: PackedStringArray = []
	var logic_lines: PackedStringArray = []
	
	var count: int = children.size()
	
	# Iterate backwards (High Priority -> Low Priority)
	var first_check: bool = true
	
	for i in range(count - 1, -1, -1):
		var child: RecursiveState = children[i]
		var safe_name: String = child.name.validate_node_name()
		var child_var: String = "_child_%s_%d" % [safe_name, i]
		
		# 1. Property Definitions
		prop_decls.append("var %s: RecursiveState" % child_var)
		prop_list_items.append('\t\t{ "name": "%s", "type": TYPE_OBJECT, "usage": PROPERTY_USAGE_STORAGE },' % child_var)
		
		# 2. Conditions
		var conditions: Array = child.get("activation_conditions")
		var cond_checks: PackedStringArray = []
		
		if conditions.is_empty():
			cond_checks.append("true")
		else:
			for j in range(conditions.size()):
				var cond_var: String = "_cond_%s_%d_%d" % [safe_name, i, j]
				prop_decls.append("var %s: StateCondition" % cond_var)
				prop_list_items.append('\t\t{ "name": "%s", "type": TYPE_OBJECT, "usage": PROPERTY_USAGE_STORAGE },' % cond_var)
				cond_checks.append("%s.evaluate(actor, blackboard)" % cond_var)
		
		# 3. Logic Generation
		logic_lines.append("\t# Priority %d: %s" % [i, child.name])
		
		var expr: String = "true"
		if not (cond_checks.size() == 1 and cond_checks[0] == "true"):
			var mode: int = child.get("activation_mode") # 0=AND, 1=OR
			var joiner: String = " and " if mode == 0 else " or "
			expr = joiner.join(cond_checks)
		
		var if_kw: String = "if" if first_check else "elif"
		logic_lines.append("\t%s %s:" % [if_kw, expr])
		logic_lines.append("\t\tbest_child = %s" % child_var)
		first_check = false

	# Behavior Logic (Inline update calls for performance)
	var behavior_lines: PackedStringArray = []
	var behaviors: Array = node.get("behaviors")
	if not behaviors.is_empty():
		for i in range(behaviors.size()):
			var beh_var: String = "_beh_%d" % i
			prop_decls.append("var %s: StateBehavior" % beh_var)
			prop_list_items.append('\t\t{ "name": "%s", "type": TYPE_OBJECT, "usage": PROPERTY_USAGE_STORAGE },' % beh_var)
			behavior_lines.append("if %s: %s.update(self, delta, actor, blackboard)" % [beh_var, beh_var])
	else:
		behavior_lines.append("# No behaviors")

	# Construct the final property list array string
	var prop_list_str: String = "[\n" + "\n".join(prop_list_items) + "\n\t]"

	return TEMPLATE.format({
		"target_node_name": node.name,
		"timestamp": Time.get_datetime_string_from_system(),
		"property_declarations": "\n".join(prop_decls),
		"property_list_data": prop_list_str,
		"logic_body": "\n".join(logic_lines),
		"behavior_logic": "\n\t".join(behavior_lines)
	}) + "\nconst SMASHED_CHILD_COUNT = %d\n" % children.size()

## Post-Smash Wiring: Connects the node's children/conditions/behaviors to the smashed script's variables.
static func wire_references(node: RecursiveState) -> void:
	var children: Array[RecursiveState] = []
	for c in node.get_children():
		if _is_state(c): children.append(c)
		
	var count: int = children.size()
	
	for i in range(count):
		var child: RecursiveState = children[i]
		var safe_name: String = child.name.validate_node_name()
		
		# Wire Child
		var child_var: String = "_child_%s_%d" % [safe_name, i]
		if child_var in node:
			node.set(child_var, child)
			
		# Wire Conditions
		var conditions: Array = child.get("activation_conditions")
		if not conditions.is_empty():
			for j in range(conditions.size()):
				var cond_var: String = "_cond_%s_%d_%d" % [safe_name, i, j]
				if cond_var in node:
					node.set(cond_var, conditions[j])

	# Wire Behaviors
	var behaviors: Array = node.get("behaviors")
	for i in range(behaviors.size()):
		var beh_var: String = "_beh_%d" % i
		if beh_var in node:
			node.set(beh_var, behaviors[i])

static func _is_state(node: Node) -> bool:
	return node.get_class() == "RecursiveState" or (node.get_script() and node.get_script().resource_path.ends_with("RecursiveState.gd"))
