@tool
class_name LogicSmasher extends RefCounted

## Logic Smasher
##
## Compiles a RecursiveState's child evaluation logic into a hardcoded GDScript.
## This avoids the generic loop overhead in `process_state`.

const TEMPLATE = """extends RecursiveState

# --- SMASHED STATE ---
# Generated by LogicSmasher.
# Do not edit manually. Re-smash if hierarchy changes.

{properties}

func process_state(delta: float, actor: Node, blackboard: Blackboard = null) -> void:
	# 0. Blackboard Check
	if not blackboard:
		if not parent:
			if not _owned_blackboard: _owned_blackboard = Blackboard.new()
			blackboard = _owned_blackboard
	
	# 1. PRIORITY EVALUATION (Smashed)
	var best_child: RecursiveState = null
	
{logic}
	
	# 2. SWITCH & UPDATE
	if best_child != null and best_child != active_child:
		if not active_child or not active_child.is_hierarchy_locked():
			change_active_child(best_child, actor, blackboard)
			
	# 3. BEHAVIOR UPDATE
	for b in behaviors:
		if b: b.update(self, delta, actor, blackboard)
		
	# 4. RECURSION
	if active_child:
		active_child.process_state(delta, actor, blackboard)
"""

static func smash(node: RecursiveState) -> String:
	var properties_code = ""
	var logic_code = ""
	
	# 1. Analyze Children
	# RecursiveState evaluates ALL children, but the LAST valid one wins.
	# To optimize, we can iterate BACKWARDS (Highest Priority First) and take the FIRST valid one?
	# Standard Loop:
	# for child in children: if valid: best = child
	# Optimized Loop:
	# for child in reversed(children): if valid: best = child; break
	# Yes, we can break early if we iterate backwards! This is a huge optimization.
	
	var children = []
	for c in node.get_children():
		if _is_state(c): children.append(c)
	
	# Iterate backwards (High Priority -> Low Priority)
	var count = children.size()
	for i in range(count - 1, -1, -1):
		var child = children[i]
		var child_var = "_child_%s_%d" % [child.name.validate_node_name(), i]
		
		properties_code += "@export var %s: RecursiveState\n" % child_var
		
		# Conditions
		var cond_checks = []
		var conditions = child.get("activation_conditions")
		if conditions.is_empty():
			# Always true (if we reach here and nothing higher matched? No.)
			# If a lower priority node is "always true", it acts as a default/fallback.
			# But higher priority nodes might override it.
			# If we are iterating backwards, the first one we find is the winner.
			cond_checks.append("true")
		else:
			var mode = child.get("activation_mode") # 0=AND, 1=OR
			var op = " and " if mode == 0 else " or "
			
			for j in range(conditions.size()):
				var cond_var = "_cond_%s_%d_%d" % [child.name.validate_node_name(), i, j]
				properties_code += "@export var %s: StateCondition\n" % cond_var
				cond_checks.append("%s.evaluate(actor, blackboard)" % cond_var)
			
			if cond_checks.size() > 1:
				logic_code += "\t# Priority %d: %s\n" % [i, child.name]
				logic_code += "\tif %s:\n" % [cond_checks[0]] # Just simplified logic generation below
			
		# Generate Logic Block
		# if (Conditions):
		#    best_child = child
		#    # BREAK because we are going High -> Low
		#    # Wait, is that correct?
		#    # Standard: "All children evaluated. Last valid wins."
		#    # High Prio (Last) is valid -> It wins.
		#    # So yes, break is correct.
		
		logic_code += "\t# Priority %d: %s\n" % [i, child.name]
		
		var expr = ""
		if cond_checks.size() == 1 and cond_checks[0] == "true":
			expr = "true"
		else:
			var mode = child.get("activation_mode")
			var joiner = " and " if mode == 0 else " or "
			expr = joiner.join(cond_checks)
			
		logic_code += "\tif %s:\n" % expr
		logic_code += "\t\tbest_child = %s\n" % child_var
		logic_code += "\t\t# High priority match found, stop checking lower priority.\n"
		# We can wrap this in a block that skips the rest?
		# Or use `elif` chain?
		# `elif` chain works if we structure it right.
		# But `elif` implies mutual exclusivity. Here, even if High matches, Low *could* match, but High wins.
		# So `if High: ... else: if Low: ...` is effectively `elif`.
		# So we can generate a giant if/elif chain from High to Low.
		
	# REWRITE LOGIC LOOP for if/elif chain
	logic_code = ""
	var first = true
	
	for i in range(count - 1, -1, -1):
		var child = children[i]
		var child_var = "_child_%s_%d" % [child.name.validate_node_name(), i]
		
		var cond_expr = ""
		var conditions = child.get("activation_conditions")
		
		if conditions.is_empty():
			cond_expr = "true"
		else:
			var parts = []
			for j in range(conditions.size()):
				var cond_var = "_cond_%s_%d_%d" % [child.name.validate_node_name(), i, j]
				parts.append("%s.evaluate(actor, blackboard)" % cond_var)
			
			var mode = child.get("activation_mode")
			var joiner = " && " if mode == 0 else " || "
			cond_expr = "(" + joiner.join(parts) + ")"
			
		var statement = "if" if first else "elif"
		logic_code += "\t%s %s:\n" % [statement, cond_expr]
		logic_code += "\t\tbest_child = %s\n" % child_var
		
		first = false
		
	return TEMPLATE.format({"properties": properties_code, "logic": logic_code})

static func _is_state(node: Node) -> bool:
	# Duck typing or check class name string to avoid cyclic dependency in tool
	return node.get_class() == "RecursiveState" or (node.get_script() and node.get_script().resource_path.ends_with("RecursiveState.gd"))
